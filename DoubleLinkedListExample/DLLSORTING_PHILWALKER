Script started on Sat Dec  8 15:11:41 2012
[?1034hbash-3.2$ cat part3app.cpp
//Phillip Walker
//Data Structures
//11-18-2012
//###############

#include "List.h"
#include <fstream>

int main(){
  
  //#########
  //Create variables
  //#########

  //for insert sort functionality
  Node *curr = NULL;
  
  //newNode holder
  Node *newNode = NULL;

  //List pointer
  List *list1 = NULL;

  //second list
  List *list2 = NULL;

  List *list3 = NULL;

  //Demonstration var
  char demo='n';

  //reverse copy bool
  bool copyValue=true;

  //Social Security to identify which record to insert before/after
  int social;
  
  //Create list & check memory alloc
  try{
    list1 = new List;
  }catch(bad_alloc& c){
    cerr<<"Bad memory allocation for list"<<endl;
  }
  
  //##########
  //Open File
  //##########

  ifstream INFILE;
  ofstream OUTFILE;

  string method;
  char terminate='n';

  cout << "Please enter a file name"<<endl;
  cin >> method;
  
  //Opening file                                                             
  if(method != "-"){
    INFILE.open(method.c_str());
  }
      
  //error checking if file didnt open right                                                 
  if(!INFILE){
    cout << "ERROR UNABLE TO OPEN FILE!"<<endl;
    return 1;
  }
  
  //##########
  //Build list
  //##########
  
  //Notify processes began
  cout << "Creating sorted list now..."<<endl;

  //No. nodes in list
  while(!INFILE.eof()){
    //cout << "0.1"<<endl;

    //Allocate Node memory to newNode 
    try{
      
      //cout << 1 <<endl;
      newNode = new Node(new Student(INFILE));

      //update curr
      curr = newNode;

    }catch(bad_alloc& c){
      
      //Test allocation
      cerr<<"bad memory allocation for Node"<<endl;
      return 1;
      
    }
    
    //cout << 2 << endl;
   
    //check if empty
    if(list1->isEmpty()){
      
      //attach record
      list1->append(newNode);

    }else{
      
      //cout << 3 << endl;
      //Create list/add node
      list1->buildSortedList(newNode);
      
    }
    //Ask user to quit after creating atleast 2 students                                      
    //cout << 4 << endl;
    if(!INFILE.good()){
      
      break;
      
    }
  }

  //Close File
  INFILE.close();
    
  //################
  //Demo list functions below
  //################
  
  //Demo display Descending
  cout << "Done"<<endl;
  cout<<"Displaying list1 in ascending order"<<endl;
  
  //Output list
  list1->displayAscending();
  
  //Demo delete record
  cout << "Would you like to delete a node?"<<endl;
  cin >> demo;
  
  if(demo == 'y'){
    
    cout << "Please specify which record to delete with the social security code"<<endl;
    cin >> social;
    
    //delete node
    list1->deleteNode(social);
    
    cout << "Displaying updated list"<<endl;
    list1->displayAscending();

  }


  //##############
  //Create List 2 in file format (unsorted)
  //##############

  cout << "Would you like to make a List 2?"<<endl;
  cin >> demo;

  if(demo == 'y'){
    
    cout << "Please enter a file name"<<endl;
    cin >> method;  
   
    //allocate and test                                                                                  
    try{
      list2 = new List;
    }catch(bad_alloc&c){
      cerr <<"Bad memory allocation for list 3"<<endl;
      return 1;
    }


    //Opening file                                                             
    if(method != "-"){
      INFILE.open(method.c_str());
    }
    
    //error checking if file didnt open right                                                 
    if(!INFILE){
      cout << "ERROR UNABLE TO OPEN FILE!"<<endl;
      return 1;
    }

    
    //No. nodes in list                                                                                      
    while(terminate != 'y' || INFILE.eof()){
      
      //Allocate Node memory to newNode                                                                      
      try{
	
	if(method == "-"){
	  newNode = new Node(new Student());
	}
	else{
	  newNode = new Node(new Student(INFILE));
	}
	
      }catch(bad_alloc& c){
	//Test allocation                                                                                    
	
	cerr<<"bad memory allocation for Node"<<endl;
	return 1;
	
      }
      
      //Create list/add node                                                                                 
      list2->append(newNode);
      
      //Ask user to quit after creating atleast 2 students                                                   
      if(method == "-"){
	
	//ask to exit or not                                                                                 
	cout << "Would you like to exit? (y/n)"<<endl;
	cin>> terminate;
	
      }else if(!INFILE.good()){
	
	break;
	
      }
    }
  }
  
  //Dipslay List 2
  list2->displayAscending();
  
  //Demo create new list in reverse with bool value
  cout << "Would you like to copy list2 in a special way!? (y/n)"<<endl;
  cin >> demo;
  
  if(demo == 'y'){
  
    //msg to user
    cout << "Would you like to copy the list in reverse order (y)  or normal order (n)?"<<endl;
    cin >> demo;
    
    if(demo == 'y'){
      
      //reverse list
      copyValue = false;
      
      //allocate and test
      try{
	list3 = new List(list2, copyValue);
      }catch(bad_alloc& c){
	cerr << "Bad memory allocation for list 3"<<endl;
	return 1;
      }
      
      cout << "Displaying list 3 (reversed list 2)"<<endl;
      cout << "Ascending order"<<endl;
      list3->displayAscending();

    }else{
      //not reversed
      
      //allocate and test
      try{
	list3 =new List(list2);
      }catch(bad_alloc&c){
	cerr <<"Bad memory allocation for list 3"<<endl;
	return 1;
      }
      
      //display
      cout << "Dispaying list 3 (not reversed of list 2)"<<endl;
      list3->displayAscending();
      
    }
  }//if

  //List 2 Head -> tail
  
  cout << "Displaying List 2 Ascending order"<<endl;
  list2->displayAscending();

  // List 3 in tail -> head

  cout << "Displaying List 3 in Descending order"<<endl;
  list3->displayDescending(list3->getTail());
  cout << endl;
  
  //Demo delete record
  cout << "Would you like to delete a node from List 2?"<<endl;
  cin >> demo;
  
  if(demo == 'y'){
    
    cout << "Please specify which record to delete with the social security code"<<endl;
    cin >> social;
    

    
    //delete node
    list2->deleteNode(social);
    
    //output updated
    cout << "Displaying updated list"<<endl;
    list2->displayAscending();

  }
 
  //Selection Sort
  cout << "Sorting list 2 with selection sort"<<endl;
  list2->selectionSort();

  cout << "Displaying recently selection sorted list"<<endl;
  list2->displayAscending();

  //Bubble sort
  cout << "Sorting list 3 with Bubble Sort"<<endl;
  list3->bubbleSort();
  
  cout << "displaying bubble sorted list"<<endl;
  list3->displayAscending();
  
 
  
  

  return 0;

}







bash-3.2$ cat Node.h
#ifndef NODE_H
#define NODE_H

#include "Student.h"

#include <iostream>
#include <string>


using namespace std;


class Node{

 public:
  
  //Default constructor
  Node();
  
  //Constructor
  Node(Student*);
  
  //Destructor
  ~Node();

  //Set next
  void setNext(Node*);
  
  //Set prev
  void setPrev(Node*);
  
  //Get next node
  Node *getNext();

  //Get prev node
  Node *getPrev();

  //Get data
  Student* getData();
  

 private:

  //Pointer var
  Node *next_;
  Node *prev_;
  
  //Data var
  Student* data_;



};
#endif
bash-3.2$ cat Node.h[Kcpp 
#include "Node.h"

//Create defualt constructor

Node::Node(){
  
}

//Constructor
//@param item: data item value

Node::Node(Student* item){
  
  //Setting data var of node
  data_ = item;
  
  //Set pointer to NULL
  next_ = NULL;
  prev_ = NULL;

}

//Destructor

Node::~Node(){
  
  delete data_;
  delete next_;
  delete prev_;

}

//getNext node

Node* Node::getNext(){

  return next_;

}

//getPrev node
Node* Node::getPrev(){
  
  return prev_;

}

//SetPrev pointer
void Node::setPrev(Node* newNode){

  //Point to prev
  prev_ = newNode;

}

//SetNext pointer

void Node::setNext(Node* newNode){

  //Point to next node
  next_ = newNode;

}

//Get node data 

Student* Node::getData(){
  
  return data_;
  
}
    
bash-3.2$ cat List.h
#ifndef LIST_H
#define LIST_H

#include "Node.h"

class List{

 private:
  
  //Node pointers

  //First node pointer
  Node* head_;
  
  //Last node pointer
  Node* tail_;

  //Iterating list nodes
  Node* currNode;

  //private methods

  //Append to end of list
  void appendLastNode(Node*);

  //Iterate down list
  Node* iterateDown();

  //Itrate up list
  Node* iterateUp();

  //Dynamically create new node
  Node* createNewNode(Student*);

  //swap function
  void swap(Node*, Node*);

 public:

  //Default constructor
  List();

  //Copy constructor regular list
  List(List*);
  
  //Copy constructor reversed list
  List(List*, bool);

  //Destructor
  ~List();

  //isEmpty checks if the list is empty (true) or not (false)
  bool isEmpty();

  //tail accessor
  Node* getTail();
  
  //Append function
  void append(Node*);

  //insert node before node
  void insertBeforeNode(Node*, int x);

  //insert node before node
  void insertAfterNode(Node*, int x);
  
  //insert to head of list
  void insertFirstNode(Node*);

  //Delete a node
  void deleteNode(int);
  
  //Traverse Forward
  void displayAscending();

  //Traversing Backward
  void displayDescending(Node*);
  
  //Return length of list
  int getNumNodes();
  
  //Return next Node in list
  Node* newIteratorHead();

  //Return new tail iterator
  Node* newIteratorTail();

  //Build a list sorted by student age
  void buildSortedList(Node*);
  
  //Selection Sort
  void selectionSort();
  
  //Bubble sort
  void bubbleSort();


};
#endif
bash-3.2$ cat List.cpp
#include "List.h"

//Default constructor

List::List(){

  head_ = NULL;
  tail_ = NULL;  

}

//Destructor

List::~List(){

  //delete nodes
  Node* curr = head_;  

  //traverse and delete all
  while(curr != NULL){
    
    deleteNode(curr->getData()->getSocial());
    curr = curr->getNext();
    
  }

  //delete pointers
  delete tail_;
  delete head_;

}

//Copy Constructor

List::List(List* A){
  
  //curr node
  Node* n;
  
  //data var
  Student* data;
  
  //Begin iterating list
  n = A->newIteratorHead();

  //cout << 1 << endl;

  //While node exists

  while(n){

    //cout<<2<<endl;
    
    //extract data 
    data = n->getData();
    //cout << 3<<endl;
    //add newnode to list
  
    append(createNewNode(data));
    
    //cout << 4<<endl;
    //iterate node
    
    n = A->iterateDown();
    //cout << 5<<endl;
  
  }//end while
}

//Copy Constructor with reverse option
//
//@param A: list to copy
//@aparam flag: true regular way, false reverse way

List::List(List* A, bool flag){

  Node* n; 

  Student* data; 
  
  //if reversed
  if(flag == false){
    
    //begin iterating list
    n = A->newIteratorTail();
    
    //While node exists
    while(n){
      
      //extract data 
      data = n->getData();
      
      //add newnode to list
      append(createNewNode(data));

      //iterate node
      n = A->iterateUp();
     
    }//end while
    
  }else{
    
    //get head
    n = A->newIteratorHead();

     //While node exists
    while(n){
      
      //extract data 
      data = n->getData();
      
      //add newnode to list
      append(createNewNode(data));
      
      //iterate node
      n = A->iterateDown();
      
    }//end while
  }//end if
}


//Initialize iteration for a list

Node* List::newIteratorHead(){
  
  //access head 
  currNode = head_;
  
  //return head node
  return currNode;

}

//new Iterator starting at tail

Node* List::newIteratorTail(){

  //currNode starts at tail
  currNode = tail_;

  //return start at tail
  return currNode;


}

//Iterate down node list
 
Node* List::iterateDown(){
   
  //interate next node
  currNode = currNode->getNext();

  //return next node
  return currNode;

}

//Iterate up node list 

Node* List::iterateUp(){

  //iterate prev node
  currNode = currNode->getPrev();

  //return prev node
  return currNode;

}

//createNewNode 
//@para x: data value of node
//Dynamincally create a new Node with
//data. Return node to list specifically for copying

Node* List::createNewNode(Student* data){
  //cout << 6<<endl;
  //temporary node pointer
  Node* tmpNode;
  
  //create newnode
  tmpNode = new Node(data);
  
  //cout << 7<<endl;
  //return to list
  
  return tmpNode;

}


//isEmpty returns true (list empty)
//false (list not empty)

bool List::isEmpty(){

  //if tail_ and head_ == NULL
  if(tail_ == NULL && head_ == NULL){

    //Empty
    return true;

  }else{

    //Not empty
    return false;

  }
}

//Append node to tail
//@param newNode: node to add

void List::appendLastNode(Node *newNode){
  
  //newNode next point to NULL --> new tail node
  newNode->setNext(NULL);
  
  //Points newNode prev pointer to old tail node
  newNode->setPrev(tail_);
  
  //set old tail node to new tail node
  tail_->setNext(newNode);
  
  //tail_ = new tail node
  tail_ = newNode;
  
}

// append a new node
//
//@param newNode: new node to add
//check if empty. If true, insert new node as first

void List::append(Node *newNode){
  //cout << 8<<endl;
  //If list empty
  
  if(isEmpty()){
  
    //cout << 9<<endl;
    //Insert node
    
    insertFirstNode(newNode);
    
  }else{
    
    //cout << 10<<endl;
    //append to end
    
    appendLastNode(newNode);
    
  }//end if
}

//Append First Node
//
//@param newNode: node to add
// if empty true, set head & tail else
//switch head and new node pointers

void List::insertFirstNode(Node *newNode){
  
  if(isEmpty()){

    //do something
    head_ = newNode;
    tail_ = newNode;

  }else{

    //old head to newNode
    head_->setPrev(newNode);

    //newNode to frm head
    newNode->setNext(head_);
    
    // head to newnode
    head_ = newNode;
    
    //Head node to NULL
    newNode->setPrev(NULL);
  
  }
}

//Insert before designated node
//
//@param newNode: The node to be inserted
//@param x: value of social security node to insert before

void List::insertBeforeNode(Node* newNode, int x){
  
  //begin at head
  Node* current = head_;
  //cout << "i"<<endl;

  //traverse the list until we find correct node
  while(current->getData()->getSocial() != x){
    //cout << "ii"<<endl;
    current = current->getNext();
    
  }  
  //cout << "iii"<<endl;
  //Point newNode next to current
  newNode->setNext(current);
  //cout << "iv"<<endl;
  //Point newNode prev to current->getPrev()
  newNode->setPrev(current->getPrev());
  //cout << "v"<<endl;
  //Now connect current->getPrev() to newNode
  current->getPrev()->setNext(newNode);
  //cout << "vi"<<endl;
  //Set current prev to newNode connecting current to newNode
  current->setPrev(newNode);
  //cout << "vii"<<endl;

}

//Insert after designated node
//@param newNode: The node to be inserted
//@param x: value of social security node to insert aftr

void List::insertAfterNode(Node* newNode, int x){
  
  //begin at head
  Node* current = head_;
  
  ///traverse list until we find correct node
  while(current->getData()->getSocial() != x){
    
    //increment node
    current = current->getNext();
  
  }
  
  //newNode next point to current next
  newNode->setNext(current->getNext());

  //newNode prev point to current
  newNode->setPrev(current);

  //current next prev set to newNode
  current->getNext()->setPrev(newNode);
  
  //current next to newNode
  current->setNext(newNode);
  
}


//Delete a specific node
//@param x: Node social secuirty to delete

void List::deleteNode(int x){
  
  //Start at head
  Node* curr = head_;
  
  //head storage pointer before deleting
  Node* store=NULL;
  
  //cout << "*"<<endl;

  //if deleting first node case
  if(head_->getData()->getSocial() == x){
    
    //cout << "**"<<endl;
    
    //store node
    //store = head_;
    
    //cout << store->getData()->getAge()<<endl;

    //set head
    head_ = curr->getNext();
    
    //cout << "***"<<endl;
    
    //new head setNext
    head_->setNext(head_->getNext());
    
    //cout << "****"<<endl;
    
    //new head setPrev
    head_->setPrev(NULL);
    
    //cout << "#"<<endl;
    
    //Delete fmr head
    //delete store;
    
    //cout << "##"<<endl;
    
  }else if(tail_->getData()->getSocial() == x){   
    //Delete the last node
    
    //store delete node
    store = curr;

    //curr to 2nd to last (new tail)
    curr = tail_->getPrev();

    //tail pointer to 2nd to last (new tail)
    tail_ = tail_->getPrev();
    
    //set new tail next NULL
    tail_->setNext(NULL);

    //new tail to new 2nd to last 
    tail_->setPrev(curr->getPrev());

    //set new 2nd to last next to new tail
    curr->getPrev()->setNext(tail_);
    
    //delete tail node
    delete store;    

  }else{
   
    //while not correct node
    while(curr->getData()->getSocial() != x){
      
      //iterate
      curr = curr->getNext();
      
    }//end while
    
    //store delete node
    store = curr;
    
    //make node after delete node prev pointer point to node before
    //delete node
    curr->getNext()->setPrev(curr->getPrev());
    
    //connect node after store to node prev to store
    curr->getPrev()->setNext(curr->getNext()); 
    
  }//end else
  
}

//displayAscending
//display all nodes from head to tail 

void List::displayAscending(){

  //current node
  Node *curr;

  //begin at head
  curr = head_;
  
  //while not end of list
  while(curr != NULL){

    //display data
    cout << curr->getData()->getAge();
    cout << " ";
    //->display()
    
    //iterate to next node
    curr = curr->getNext();
    
  }//end while
  cout << endl;
}


//displayDescending
//Implemented recursively
//
//@param preNode: prev node of each node

void List::displayDescending(Node* prevNode){

  //if top of list
  if(prevNode->getPrev() == NULL){
    
    //display head
    cout << prevNode->getData()->getAge();
    cout << " ";
    //->display();
    
  }else{
    //continue up list

    //display data
    cout << prevNode->getData()->getAge();
    cout << " ";
    //->display();
    
    //iterate up list
    displayDescending(prevNode->getPrev());

  }//end if
}

//getNumNodes
//return the length of the list

int List::getNumNodes(){

  //curr node
  Node* curr;
  
  //count nodes
  int i=0;
  
  //begin at head
  curr = head_;
 
  //while node exists
  while(curr->getNext() != NULL){

    //increment i for each node
    i++;

    //traverse list
    curr = curr->getNext();

  }//end while

  //return total number of nodes
  return i;

}

//Get tail pointer

Node* List::getTail(){

  return tail_;

}

//Build a list sorted by age
//
//@param newNode: student record to input
//@param curr: Current node the list is on

void List::buildSortedList(Node* newNode){

  Node* curr = head_;
  //cout << "a"<<endl;

  if(newNode->getData()->getAge() > curr->getData()->getAge()){
    //cout << 'b'<<endl;
    
    insertFirstNode(newNode);
    
    //cout << 'c'<<endl;

  }else if(newNode->getData()->getAge() < tail_->getData()->getAge()){

    //cout << 'e' <<endl;

    append(newNode);
    
    //cout << 'f' << endl;

  }else{
    
    //cout << 'g'<<endl;

    curr = curr->getNext();
    
    //cout << 'h' <<endl;
    
    while(curr != NULL){
    
      //cout << 'i' <<endl;
      
      if(newNode->getData()->getAge() > curr->getData()->getAge()){
	
	//cout << 'j'<<endl;
	
	//cout << newNode->getData()->getAge()<<endl;
	//cout << curr->getData()->getAge()<<endl;

	insertBeforeNode(newNode, curr->getData()->getSocial());
	
	//cout << "Breaking"<<endl;
	break;
	
	//cout << 'k' <<endl;
	
      }

      //cout << 'l'<<endl;

      curr = curr->getNext();
      
    } 
  } 
}

//Selection Sort Algorithm performed on a list of nodes

void List::selectionSort(){

  //Updating min
  Node* min;
  
  //cout << "enter for"<<endl;
  //loop thru n-1 times
  for(Node* i = head_; i != NULL; i = i->getNext() ){
    //cout << "Starting i loop with: " << i->getData()->getAge()<<endl;

    //cout << "i just update"<<endl;
    min = i;

    //visit i+1 to n-1
    for(Node* j = i->getNext(); j != NULL; j = j->getNext()){
      
      //cout << "NEW LIST NEW LIST NEW LIST NEW LIST NEW LIST NEW LIST\n\n\n\n\n"<<endl;
      
      //cout << "Checking"<<endl;
      //cout << "j: " << j->getData()->getAge() << " and " << min->getData()->getAge() << endl;
      
      if(j->getData()->getAge() < min->getData()->getAge()){
	      
	//cout << "in if: "<<endl;
	//cout << endl;
	//cout << "j: " << j->getData()->getAge() << "<" << min->getData()->getAge() << endl;
        
	//cout << "Smallest found"<<endl;
	
        min = j;
	
      }
      
      //displayAscending();
      //cout << "Infiniti is fun! Look! " << endl;
      //break;
    }
    
    //cout << "Swapping "<<endl;
    //cout << "i: " << i->getData()->getAge() << " and min: " << min->getData()->getAge() << endl;
    
    
    //Perform Swap
    swap(i, min);
    //displayAscending();

    i = min;
    
  }
}

//Bubble Sorting Algorithm

void List::bubbleSort(){

  Node* j = head_;
  bool flag=true;

  for(Node* i = head_; i->getNext() != NULL; i=i->getNext()){
    
    while(j->getNext() != NULL){
      
      //cout<<"j: "<< j->getData()->getAge() << " and j next" << j->getNext()->getData()->getAge()<<endl;
      
      if(j->getNext()->getData()->getAge() < j->getData()->getAge()){
	
	//cout << "Swap"<<endl;
	swap(j, j->getNext());
	//cout<<"J prev: " << j->getPrev()->getData()->getAge()<<endl;
    
      }else{

	//cout <<"j was: "<<j->getPrev()->getData()->getAge()<<endl;
	//cout <<"j now: "<<j->getData()->getAge()<<endl;
	
	//cout << 333 << endl;
	j = j->getNext();
      
      }
      
    }
    j = head_;
    //cout << 99 << endl;
  }
}

//Swap node function
//
//@param min: this is the i node
//@param j: this is the smallest element denoted by j's count in 
//selection sort algorithm
//                  min         j
void List::swap(Node* a, Node* b){
  
  //Set swapping nodes
  Node* ap = a->getPrev();
  Node* an = a->getNext();
  Node* bp = b->getPrev();
  Node* bn = b->getNext();

  //normal / head tail swap
  if(an) an->setPrev(b);
  
  if(bn) bn->setPrev(a);

  if(bp) bp->setNext(a);
  
  if(ap) ap->setNext(b);

  if(an == b){
    
    
    b->setNext(a);
    a->setPrev(b);
    b->setPrev(ap);
    a->setNext(bn);

    
  }else if (bn == a){
        
    a->setNext(b);
    b->setPrev(a);
    b->setNext(an);
    a->setPrev(bp);

  }else{
    
    b->setNext(an);
    a->setPrev(bp);
    b->setPrev(ap);
    a->setNext(bn);

  }

  //Account tail/head
  if(!ap) head_ = b;
  
  if(!bn) tail_ = a;

  if(!bp) head_ = a;
  
  if(!an) tail_ = b;

  
  
}
bash-3.2$ cat Student.h
#ifndef STUDENT_H
#define STUDENT_H
#include <iostream>
#include <fstream>

using namespace std;

class Student{


 private:
  //Data Members                                                                               
  string fname;
  string lname;
  char mi;
  long socialSecurity;
  int age;


 public:
  //default constructor for terminal input                                                     
  Student();

  //constructor                                                                                
  Student(ifstream&);

  //display items                                                                              
  void display(ofstream&);
  
  //display items                                                                              
  void display();

  //accessors                                                                                  
  string getFname();
  string getLname();
  char getMi();
  long getSocial();
  int getAge();

};
#endif
 
bash-3.2$ cat Student.cpp 
#include "Student.h"

//defualt constructor                                                                           
Student::Student(){

  //Get first name                                                                             
  cout<<"First Name: ";
  cin >> fname;

  //Get last name                                                                              
  cout << "Last Name: ";
  cin >> lname;

  //Get middle initial                                                                         
  cout<<"Middle Initial: ";
  cin >> mi;

  cout << "Social Security: ";
  cin >> socialSecurity;

  cout << "Age: ";
  cin >> age;


}

//constructor                                                                                   
Student::Student(ifstream &in){

  //input from file
  in >> fname >> mi >> lname >> socialSecurity >> age;
  
  /*
  in >> fname;

  in >> lname;

  in >> mi;

  in >> socialSecurity;

  in >> age;

  in.ignore();
  */
}


//Display the node's student object data members                                                
void Student::display(ofstream &out){

  out << "Information of Student: \n\n" <<  "First name: " << fname << "\n" <<"Middle Initial:\
 "<< mi << "\n" <<"Last name: "<< lname << "\n" <<"Social Security: " << socialSecurity << "\n"\
      << "Age: "<< age << "\n" <<endl;

}

void Student::display(){
  cout << "Information of Student: \n\n" <<  "First name: " << fname << "\n" <<"Middle Initial\
: "<< mi << "\n" <<"Last name: "<< lname << "\n" <<"Social Security: " << socialSecurity << "\n\
" << "Age: "<< age << "\n"<<endl;
}


//Get the first name of the student                                                             
string Student::getFname(){
  return(fname);
}

//Get the last name of the student                                                              
string Student::getLname(){
  return(lname);
}


//get middle initial                                                                            
char Student::getMi(){
  return(mi);
}

//get social security number                                                                    
long Student::getSocial(){
  return(socialSecurity);
}

//get age                                                                                       
int Student::getAge(){
  return(age);
}
 
bash-3.2$ ./a.out 
Please enter a file name
DATA.dat
Creating sorted list now...
Done
Displaying list1 in ascending order
92 54 50 35 27 24 22 22 20 19 16 14 
Would you like to delete a node?
y
Please specify which record to delete with the social security code
33394485
Displaying updated list
92 54 35 27 24 22 22 20 19 16 14 
Would you like to make a List 2?
y
Please enter a file name
DATA.dat
50 54 20 14 92 24 16 35 22 27 19 22 
Would you like to copy list2 in a special way!? (y/n)
y
Would you like to copy the list in reverse order (y)  or normal order (n)?
y
Displaying list 3 (reversed list 2)
Ascending order
22 19 27 22 35 16 24 92 14 20 54 50 
Displaying List 2 Ascending order
50 54 20 14 92 24 16 35 22 27 19 22 
Displaying List 3 in Descending order
50 54 20 14 92 24 16 35 22 27 19 22 
Would you like to delete a node from List 2?
y
Please specify which record to delete with the social security code
33394485
Displaying updated list
54 20 14 92 24 16 35 22 27 19 22 
Sorting list 2 with selection sort
Displaying recently selection sorted list
14 16 19 20 22 22 24 27 35 54 92 
Sorting list 3 with Bubble Sort
displaying bubble sorted list
14 16 19 20 22 22 24 27 35 50 54 92 
bash-3.2$ exit
exit

Script done on Sat Dec  8 15:12:39 2012
